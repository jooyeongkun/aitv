const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const db = require('./database');
const axios = require('axios');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

console.log('🚀 Socket.IO server initialized');

app.use(cors());
app.use(express.json());

// 관리자 로그인
app.post('/api/admin/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    const result = await db.query('SELECT * FROM admins WHERE username = $1', [username]);
    if (result.rows.length === 0) {
      return res.status(401).json({ error: '아이디 또는 비밀번호가 틀렸습니다.' });
    }

    const admin = result.rows[0];
    const validPassword = await bcrypt.compare(password, admin.password_hash);
    
    if (!validPassword) {
      return res.status(401).json({ error: '아이디 또는 비밀번호가 틀렸습니다.' });
    }

    const token = jwt.sign(
      { adminId: admin.id, username: admin.username },
      process.env.JWT_SECRET,
      { expiresIn: '8h' }
    );

    // 온라인 상태 업데이트
    await db.query('UPDATE admins SET is_online = true WHERE id = $1', [admin.id]);

    res.json({
      token,
      admin: {
        id: admin.id,
        username: admin.username,
        name: admin.name
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: '서버 오류가 발생했습니다.' });
  }
});

// 대화 목록 조회
app.get('/api/conversations', async (req, res) => {
  try {
    console.log('API: Getting conversations...');
    const result = await db.query(`
      SELECT c.id, c.session_id, c.admin_id, c.customer_name, c.status, 
             c.created_at, c.updated_at,
             COUNT(m.id) as message_count,
             MAX(m.created_at) as last_message_time
      FROM conversations c
      LEFT JOIN messages m ON c.id = m.conversation_id
      GROUP BY c.id, c.session_id, c.admin_id, c.customer_name, c.status, c.created_at, c.updated_at
      ORDER BY c.updated_at DESC
    `);
    
    console.log('API: Conversations found:', result.rows);
    res.json(result.rows);
  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({ error: '서버 오류가 발생했습니다.' });
  }
});

// 특정 대화의 메시지 조회
app.get('/api/conversations/:id/messages', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('API: Getting messages for conversation:', id);
    
    const result = await db.query(`
      SELECT m.*, a.name as admin_name
      FROM messages m
      LEFT JOIN admins a ON m.sender_id = a.id AND m.sender_type = 'admin'
      WHERE m.conversation_id = $1
      ORDER BY m.created_at ASC
    `, [id]);
    
    console.log('API: Messages found:', result.rows);
    res.json(result.rows);
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({ error: '서버 오류가 발생했습니다.' });
  }
});

// Socket.io 연결 처리
io.on('connection', (socket) => {
  console.log('🟢 User connected:', socket.id);

  // 고객 채팅 시작
  socket.on('start-chat', async (data) => {
    try {
      const { sessionId, customerName } = data;
      
      // 기존 대화 찾기 또는 새 대화 생성
      let result = await db.query('SELECT * FROM conversations WHERE session_id = $1', [sessionId]);
      
      if (result.rows.length === 0) {
        result = await db.query(
          'INSERT INTO conversations (session_id, customer_name, status) VALUES ($1, $2, $3) RETURNING *',
          [sessionId, customerName || null, 'waiting']
        );
      }
      
      const conversation = result.rows[0];
      socket.join(`conversation_${conversation.id}`);
      
      socket.emit('chat-started', { conversationId: conversation.id });
      
      // 모든 관리자에게 새 채팅 알림 (관리자만 받도록)
      socket.broadcast.emit('new-chat', conversation);
      
      console.log('New chat created:', conversation.id, 'Session:', conversation.session_id);
      
    } catch (error) {
      console.error('Start chat error:', error);
      socket.emit('error', { message: '채팅을 시작할 수 없습니다.' });
    }
  });

  // 메시지 전송
  socket.on('send-message', async (data) => {
    try {
      const { conversationId, message, senderType, senderId } = data;
      
      console.log('🔵 Message received:', { conversationId, message, senderType });
      
      // 메시지 DB 저장
      const result = await db.query(
        'INSERT INTO messages (conversation_id, sender_type, sender_id, message_text) VALUES ($1, $2, $3, $4) RETURNING *',
        [conversationId, senderType, senderId || null, message]
      );
      
      const newMessage = result.rows[0];
      
      // 대화방 업데이트 시간 갱신
      await db.query('UPDATE conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = $1', [conversationId]);
      
      console.log('Broadcasting message to conversation room:', `conversation_${conversationId}`);
      
      // 해당 대화방의 모든 사용자에게 메시지 전송
      io.to(`conversation_${conversationId}`).emit('new-message', newMessage);
      
      // 관리자에게도 새 메시지 알림 (대화 목록 업데이트용)
      socket.broadcast.emit('conversation-updated', conversationId);
      
      // 고객 메시지인 경우 AI 자동 응답 처리
      if (senderType === 'customer') {
        try {
          // AI 서비스에 요청
          const aiResponse = await axios.post('http://localhost:5000/chat', {
            message: message,
            conversation_id: conversationId
          }, {
            headers: {
              'Content-Type': 'application/json; charset=utf-8'
            }
          });
          
          if (aiResponse.data && aiResponse.data.response) {
            // AI 응답을 DB에 저장
            const aiMessageResult = await db.query(
              'INSERT INTO messages (conversation_id, sender_type, sender_id, message_text) VALUES ($1, $2, $3, $4) RETURNING *',
              [conversationId, 'ai', null, aiResponse.data.response]
            );
            
            const aiMessage = aiMessageResult.rows[0];
            
            // 대화방 업데이트 시간 갱신
            await db.query('UPDATE conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = $1', [conversationId]);
            
            // AI 응답을 대화방에 전송
            setTimeout(() => {
              io.to(`conversation_${conversationId}`).emit('new-message', aiMessage);
              socket.broadcast.emit('conversation-updated', conversationId);
            }, 1000); // 1초 딜레이로 자연스럽게
            
            console.log('AI response sent:', aiResponse.data.response);
          }
        } catch (aiError) {
          console.error('AI service error:', aiError.message);
          // AI 서비스 오류 시에도 기본 메시지는 정상 전송되도록
        }
      }
      
    } catch (error) {
      console.error('Send message error:', error);
      socket.emit('error', { message: '메시지를 전송할 수 없습니다.' });
    }
  });

  // 관리자가 대화방 입장
  socket.on('join-conversation', async (data) => {
    try {
      const { conversationId, adminId } = data;
      
      socket.join(`conversation_${conversationId}`);
      
      // 대화방에 관리자 배정
      await db.query('UPDATE conversations SET admin_id = $1, status = $2 WHERE id = $3', 
        [adminId, 'active', conversationId]);
      
    } catch (error) {
      console.error('Join conversation error:', error);
      socket.emit('error', { message: '대화방에 입장할 수 없습니다.' });
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

// 호텔 관리 API
// 호텔 목록 조회
app.get('/api/hotels', async (req, res) => {
  try {
    const result = await db.query(`
      SELECT id, hotel_name, hotel_region, 
             TO_CHAR(promotion_start, 'YYYY-MM-DD') as promotion_start,
             TO_CHAR(promotion_end, 'YYYY-MM-DD') as promotion_end,
             is_unlimited, adult_price, child_price, child_criteria, description, is_active,
             created_at, updated_at
      FROM hotels WHERE is_active = true ORDER BY created_at DESC
    `);
    res.json(result.rows || result);
  } catch (error) {
    console.error('호텔 목록 조회 오류:', error);
    res.status(500).json({ error: '호텔 목록을 가져올 수 없습니다.' });
  }
});

// 새 호텔 생성
app.post('/api/hotels', async (req, res) => {
  try {
    console.log('호텔 생성 요청 받음:', req.body);
    const { hotel_name, hotel_region, promotion_start, promotion_end, is_unlimited, adult_price, child_price, child_criteria, description } = req.body;
    
    // 빈 문자열을 null이나 기본값으로 변환
    const adult_price_val = adult_price && adult_price !== '' ? parseInt(adult_price) : null;
    const child_price_val = child_price && child_price !== '' ? parseInt(child_price) : null;
    
    const result = await db.query(`
      INSERT INTO hotels (hotel_name, hotel_region, promotion_start, promotion_end, is_unlimited, adult_price, child_price, child_criteria, description)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id, hotel_name, hotel_region, 
                TO_CHAR(promotion_start, 'YYYY-MM-DD') as promotion_start,
                TO_CHAR(promotion_end, 'YYYY-MM-DD') as promotion_end,
                is_unlimited, adult_price, child_price, child_criteria, description, is_active
    `, [
      hotel_name || '', 
      hotel_region || '', 
      promotion_start || new Date().toISOString().split('T')[0], 
      promotion_end || null, 
      is_unlimited || false, 
      adult_price_val, 
      child_price_val, 
      child_criteria || '', 
      description || ''
    ]);
    
    res.json(result.rows ? result.rows[0] : { id: result.lastID, ...req.body });
  } catch (error) {
    console.error('호텔 생성 오류:', error);
    res.status(500).json({ error: '호텔을 생성할 수 없습니다.' });
  }
});


// 호텔 정보 수정
app.put('/api/hotels/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // 데이터 타입 변환
    const processedUpdates = {};
    Object.keys(updates).forEach(key => {
      let value = updates[key];
      if ((key === 'adult_price' || key === 'child_price') && value !== '' && value !== null) {
        value = parseInt(value);
      } else if ((key === 'adult_price' || key === 'child_price') && (value === '' || value === null)) {
        value = null;
      }
      processedUpdates[key] = value;
    });
    
    // 동적으로 업데이트 쿼리 생성
    const fields = Object.keys(processedUpdates);
    const values = Object.values(processedUpdates);
    const setClause = fields.map((field, index) => `${field} = $${index + 2}`).join(', ');
    
    const result = await db.query(`
      UPDATE hotels SET ${setClause}, updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
      RETURNING id, hotel_name, hotel_region, 
                TO_CHAR(promotion_start, 'YYYY-MM-DD') as promotion_start,
                TO_CHAR(promotion_end, 'YYYY-MM-DD') as promotion_end,
                is_unlimited, adult_price, child_price, child_criteria, description, is_active
    `, [id, ...values]);
    
    res.json(result.rows ? result.rows[0] : { id, ...updates });
  } catch (error) {
    console.error('호텔 수정 오류:', error);
    res.status(500).json({ error: '호텔 정보를 수정할 수 없습니다.' });
  }
});

// 호텔 삭제
app.delete('/api/hotels/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`호텔 삭제 요청 받음: ID ${id}`);
    
    // 완전 삭제
    const result = await db.query('DELETE FROM hotels WHERE id = $1', [id]);
    console.log(`삭제 결과:`, result.rowCount);
    
    res.json({ message: '호텔이 삭제되었습니다.', deletedRows: result.rowCount });
  } catch (error) {
    console.error('호텔 삭제 오류:', error);
    res.status(500).json({ error: '호텔을 삭제할 수 없습니다.' });
  }
});

// 투어 관리 API
// 투어 목록 조회
app.get('/api/tours', async (req, res) => {
  try {
    const result = await db.query(`
      SELECT id, tour_name, tour_region, duration,
             adult_price, child_price, infant_price, 
             child_criteria, infant_criteria, description, is_active,
             created_at, updated_at
      FROM tours WHERE is_active = true ORDER BY created_at DESC
    `);
    res.json(result.rows || result);
  } catch (error) {
    console.error('투어 목록 조회 오류:', error);
    res.status(500).json({ error: '투어 목록을 가져올 수 없습니다.' });
  }
});

// 새 투어 생성
app.post('/api/tours', async (req, res) => {
  try {
    console.log('투어 생성 요청 받음:', req.body);
    const { tour_name, tour_region, duration, adult_price, child_price, infant_price, child_criteria, infant_criteria, description } = req.body;
    
    // 빈 문자열을 null이나 기본값으로 변환
    const adult_price_val = adult_price && adult_price !== '' ? parseInt(adult_price) : null;
    const child_price_val = child_price && child_price !== '' ? parseInt(child_price) : null;
    const infant_price_val = infant_price && infant_price !== '' ? parseInt(infant_price) : null;
    
    const result = await db.query(`
      INSERT INTO tours (tour_name, tour_region, duration, adult_price, child_price, infant_price, child_criteria, infant_criteria, description)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id, tour_name, tour_region, duration, adult_price, child_price, infant_price, 
                child_criteria, infant_criteria, description, is_active
    `, [
      tour_name || '', 
      tour_region || '', 
      duration || '',
      adult_price_val, 
      child_price_val, 
      infant_price_val,
      child_criteria || '', 
      infant_criteria || '',
      description || ''
    ]);
    
    console.log('투어 생성 응답:', result.rows[0]);
    res.json(result.rows ? result.rows[0] : { id: result.lastID, ...req.body });
  } catch (error) {
    console.error('투어 생성 오류:', error);
    res.status(500).json({ error: '투어를 생성할 수 없습니다.' });
  }
});

// 투어 정보 수정
app.put('/api/tours/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // 데이터 타입 변환
    const processedUpdates = {};
    Object.keys(updates).forEach(key => {
      let value = updates[key];
      if ((key === 'adult_price' || key === 'child_price' || key === 'infant_price') && value !== '' && value !== null) {
        value = parseInt(value);
      } else if ((key === 'adult_price' || key === 'child_price' || key === 'infant_price') && (value === '' || value === null)) {
        value = null;
      }
      processedUpdates[key] = value;
    });
    
    // 동적으로 업데이트 쿼리 생성
    const fields = Object.keys(processedUpdates);
    const values = Object.values(processedUpdates);
    const setClause = fields.map((field, index) => `${field} = $${index + 2}`).join(', ');
    
    const result = await db.query(`
      UPDATE tours SET ${setClause}, updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
      RETURNING id, tour_name, tour_region, duration, adult_price, child_price, infant_price,
                child_criteria, infant_criteria, description, is_active
    `, [id, ...values]);
    
    res.json(result.rows ? result.rows[0] : { id, ...updates });
  } catch (error) {
    console.error('투어 수정 오류:', error);
    res.status(500).json({ error: '투어 정보를 수정할 수 없습니다.' });
  }
});

// 투어 삭제
app.delete('/api/tours/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // 완전 삭제
    const result = await db.query('DELETE FROM tours WHERE id = $1', [id]);
    
    res.json({ message: '투어가 삭제되었습니다.', deletedRows: result.rowCount });
  } catch (error) {
    console.error('투어 삭제 오류:', error);
    res.status(500).json({ error: '투어를 삭제할 수 없습니다.' });
  }
});

const PORT = process.env.PORT || 3004;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});